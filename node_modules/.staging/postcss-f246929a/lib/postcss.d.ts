/**
 * @param plugins Can also be included with the Processor#use method.
 * @returns A processor that will apply plugins as CSS processors.
 */
declare function postcss(plugins?: postcss.AcceptedPlugin[]): postcss.Processor;
declare function postcss(...plugins: postcss.AcceptedPlugin[]): postcss.Processor;
declare namespace postcss {
    type AcceptedPlugin = Plugin<any> | Transformer | {
        postcss: TransformCallback | Processor;
    } | Processor;
    /**
     * Creates a PostCSS plugin with a standard API.
     * @param name Plugin name. Same as in name property in package.json. It will
     * be saved in plugin.postcssPlugin property.
     * @param initializer Will receive plugin options and should return functions
     * to modify nodes in input CSS.
     */
    function plugin<T>(name: string, initializer: PluginInitializer<T>): Plugin<T>;
    interface Plugin<T> extends Transformer {
        (opts?: T): Transformer;
        postcss: Transformer;
        process: (css: string | {
            toString(): string;
        } | Result, opts?: any) => LazyResult;
    }
    interface Transformer extends TransformCallback {
        postcssPlugin?: string;
        postcssVersion?: string;
    }
    interface TransformCallback {
        /**
         * @returns Asynchronous plugins should return a promise.
         */
        (root: Root, result?: Result): void | Function | any;
    }
    interface PluginInitializer<T> {
        (pluginOptions?: T): Transformer;
    }
    /**
     * Contains helpers for working with vendor prefixes.
     */
    export namespace vendor {
        /**
         * @returns The vendor prefix extracted from the input string.
         */
        function prefix(prop: string): string;
        /**
         * @returns The input string stripped of its vendor prefix.
         */
        function unprefixed(prop: string): string;
    }
    export class Stringifier {
        builder: Stringifier.Builder;
        constructor(builder?: Stringifier.Builder);
        stringify(node: Node, semicolon?: boolean): void;
        root(node: any): void;
        comment(node: any): void;
        decl(node: any, semicolon: any): void;
        rule(node: any): void;
        atrule(node: any, semicolon: any): void;
        body(node: any): void;
        block(node: any, start: any): void;
        raw(node: Node, own: string, detect?: string): any;
        rawSemicolon(root: any): any;
        rawEmptyBody(root: any): any;
        rawIndent(root: any): any;
        rawBeforeComment(root: any, node: any): any;
        rawBeforeDecl(root: any, node: any): any;
        rawBeforeRule(root: any): any;
        rawBeforeClose(root: any): any;
        rawBeforeOpen(root: any): any;
        rawColon(root: any): any;
        beforeAfter(node: any, detect: any): any;
        rawValue(node: any, prop: any): any;
    }
    export namespace Stringifier {
        interface Builder {
            (str: string, node?: Node, str2?: string): void;
        }
    }
    /**
     * Default function to convert a node tree into a CSS string.
     */
    function stringify(node: Node, builder: Stringifier.Builder): void;
    /**
     * Parses source CSS.
     * @param css The CSS to parse.
     * @param options
     * @returns {} A new Root node, which contains the source CSS nodes.
     */
    function parse(css: string | {
        toString(): string;
    } | LazyResult | Result, options?: {
        from?: string;
        map?: postcss.SourceMapOptions;
    }): Root;
    /**
     * Contains helpers for safely splitting lists of CSS values, preserving
     * parentheses and quotes.
     */
    export namespace list {
        /**
         * Safely splits space-separated values (such as those for background,
         * border-radius and other shorthand properties).
         */
        function space(str: string): string[];
        /**
         * Safely splits comma-separated values (such as those for transition-* and
         * background  properties).
         */
        function comma(str: string): string[];
    }
    /**
     * Creates a new Comment node.
     * @param defaults Properties for the new Comment node.
     * @returns The new node.
     */
    function comment(defaults?: CommentNewProps): Comment;
    /**
     * Creates a new AtRule node.
     * @param defaults Properties for the new AtRule node.
     * @returns The new node.
     */
    function atRule(defaults?: AtRuleNewProps): AtRule;
    /**
     * Creates a new Declaration node.
     * @param defaults Properties for the new Declaration node.
     * @returns The new node.
     */
    function decl(defaults?: DeclarationNewProps): Declaration;
    /**
     * Creates a new Rule node.
     * @param defaults Properties for the new Rule node.
     * @returns The new node.
     */
    function rule(defaults?: RuleNewProps): Rule;
    /**
     * Creates a new Root node.
     * @param defaults Properties for the new Root node.
     * @returns The new node.
     */
    function root(defaults?: Object): Root;
    interface SourceMapOptions {
        /**
         * Indicates that the source map should be embedded in the output CSS as a
         * Base64-encoded comment. By default, it is true. But if all previous maps
         * are external, not inline, PostCSS will not embed the map even if you do
         * not set this option.
         *
         * If you have an inline source map, the result.map property will be empty,
         * as the source map will be contained within the text of result.css.
         */
        inline?: boolean;
        /**
         * Source map content from a previous processing step (e.g., Sass compilation).
         * PostCSS will try to read the previous source map automatically (based on comments
         * within the source CSS), but you can use this option to identify it manually.
         * If desired, you can omit the previous map with prev: false.
         */
        prev?: any;
        /**
         * Indicates that PostCSS should set the origin content (e.g., Sass source)
         * of the source map. By default, it is true. But if all previous maps do not
         * contain sources content, PostCSS will also leave it out even if you do not set
         * this option.
         */
        sourcesContent?: boolean;
        /**
         * Indicates that PostCSS should add annotation comments to the CSS. By default,
         * PostCSS will always add a comment with a path to the source map. PostCSS will
         * not add annotations to CSS files that do not contain any comments.
         *
         * By default, PostCSS presumes that you want to save the source map as
         * opts.to + '.map' and will use this path in the annotation comment. A different
         * path can be set by providing a string value for annotation.
         *
         * If you have set inline: true, annotation cannot be disabled.
         */
        annotation?: boolean | string;
        /**
         * If true, PostCSS will try to correct any syntax errors that it finds in the CSS.
         * This is useful for legacy code filled with hacks. Another use-case is interactive
         * tools with live input â€” for example, the Autoprefixer demo.
         */
        safe?: boolean;
    }
    /**
     * A Processor instance contains plugins to process CSS. Create one
     * Processor  instance, initialize its plugins, and then use that instance
     * on numerous CSS files.
     */
    interface Processor {
        /**
         * Adds a plugin to be used as a CSS processor. Plugins can also be
         * added by passing them as arguments when creating a postcss instance.
         */
        use(plugin: AcceptedPlugin): Processor;
        /**
         * Parses source CSS. Because some plugins can be asynchronous it doesn't
         * make any transformations. Transformations will be applied in LazyResult's
         * methods.
         * @param css Input CSS or any object with toString() method, like a file
         * stream. If a Result instance is passed the processor will take the
         * existing Root parser from it.
         */
        process(css: string | {
            toString(): string;
        } | Result, options?: ProcessOptions): LazyResult;
        /**
         * Contains plugins added to this processor.
         */
        plugins: Plugin<any>[];
        /**
         * Contains the current version of PostCSS (e.g., "4.0.5").
         */
        version: string;
    }
    interface ProcessOptions extends Syntax {
        /**
         * The path of the CSS source file. You should always set from, because it is
         * used in source map generation and syntax error messages.
         */
        from?: string;
        /**
         * The path where you'll put the output CSS file. You should always set it
         * to generate correct source maps.
         */
        to?: string;
        syntax?: Syntax;
        /**
         * Enable Safe Mode, in which PostCSS will try to fix CSS syntax errors.
         */
        safe?: boolean;
        map?: postcss.SourceMapOptions;
        /**
         * Function to generate AST by string.
         */
        parser?: Parse | Syntax;
        /**
         * Class to generate string by AST.
         */
        stringifier?: Stringify | Syntax;
    }
    interface Syntax {
        /**
         * Function to generate AST by string.
         */
        parse?: Parse;
        /**
         * Class to generate string by AST.
         */
        stringify?: Stringify;
    }
    interface Parse {
        (css?: string, opts?: postcss.SourceMapOptions): Root;
    }
    interface Stringify {
        (node?: postcss.Node, builder?: any): postcss.Result | void;
    }
    /**
     * A promise proxy for the result of PostCSS transformations.
     */
    interface LazyResult {
        /**
         * Processes input CSS through synchronous and asynchronous plugins.
         * @param onRejected Called if any plugin throws an error.
         */
        then(onFulfilled: (result: Result) => void, onRejected?: (error: Error) => void): Function | any;
        /**
         * Processes input CSS through synchronous and asynchronous plugins.
         * @param onRejected Called if any plugin throws an error.
         */
        catch(onRejected: (error: Error) => void): Function | any;
        /**
         * Alias for css property.
         */
        toString(): string;
        /**
         * Processes input CSS through synchronous plugins and converts Root to
         * CSS string. This property will only work with synchronous plugins. If
         * the processor contains any asynchronous plugins it will throw an error.
         * In this case, you should use LazyResult#then() instead.
         * @returns Result#css.
         */
        css: string;
        /**
         * Alias for css property to use when syntaxes generate non-CSS output.
         */
        content: string;
        /**
         * Processes input CSS through synchronous plugins. This property will
         * work only with synchronous plugins. If processor contains any
         * asynchronous plugins it will throw an error. You should use
         * LazyResult#then() instead.
         */
        map: ResultMap;
        /**
         * Processes input CSS through synchronous plugins. This property will work
         * only with synchronous plugins. If processor contains any asynchronous
         * plugins it will throw an error. You should use LazyResult#then() instead.
         */
        root: Root;
        /**
         * Processes input CSS through synchronous plugins and calls Result#warnings().
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error. In this case,
         * you should use LazyResult#then() instead.
         */
        warnings(): ResultMessage[];
        /**
         * Processes input CSS through synchronous plugins. This property will work
         * only with synchronous plugins. If processor contains any asynchronous
         * plugins it will throw an error. You should use LazyResult#then() instead.
         */
        messages: ResultMessage[];
        /**
         * @returns A processor used for CSS transformations.
         */
        processor: Processor;
        /**
         * @returns Options from the Processor#process(css, opts) call that produced
         * this Result instance.
         */
        opts: ResultOptions;
    }
    /**
     * Provides the result of the PostCSS transformations.
     */
    interface Result {
        /**
         * Alias for css property.
         */
        toString(): string;
        /**
         * Creates an instance of Warning and adds it to messages.
         * @param message Used in the text property of the message object.
         * @param options Properties for Message object.
         */
        warn(message: string, options?: WarningOptions): void;
        /**
         * @returns Warnings from plugins, filtered from messages.
         */
        warnings(): ResultMessage[];
        /**
         * A CSS string representing this Result's Root instance.
         */
        css: string;
        /**
         * Alias for css property to use with syntaxes that generate non-CSS output.
         */
        content: string;
        /**
         * An instance of the SourceMapGenerator class from the source-map library,
         * representing changes to the Result's Root instance.
         * This property will have a value only if the user does not want an inline
         * source map. By default, PostCSS generates inline source maps, written
         * directly into the processed CSS. The map property will be empty by default.
         * An external source map will be generated â€” and assigned to map â€” only if
         * the user has set the map.inline option to false, or if PostCSS was passed
         * an external input source map.
         */
        map: ResultMap;
        /**
         * Contains the Root node after all transformations.
         */
        